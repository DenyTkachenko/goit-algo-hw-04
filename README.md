## Вміст
- `task1.py` — рекурсивне копіювання і сортування файлів у підпапки за розширенням.
- `task2.py` — візуалізація фракталу «сніжинка Коха» з вибором рівня рекурсії.
- `task3.py` — порівняння сортувань (Merge, Insertion, Timsort) з використанням `timeit`.
- `README.md` — інструкції, результати й висновки.

---

## Завдання 1 — Рекурсивне сортування файлів

**Синопсис**
```bash
python task1_sort_files.py SRC_DIR [DEST_DIR] [--dry-run] [--verbose]
```
- `SRC_DIR` — вихідна директорія (обов’язково).
- `DEST_DIR` — директорія призначення (необов’язково, типово `dist` біля `SRC_DIR`).
- `--dry-run` — нічого не копіює, лише друкує, що буде зроблено.
- `--verbose` — докладне логування.

Скрипт обходить `SRC_DIR` **рекурсивно**, для кожного знайденого файла створює підпапку в `DEST_DIR` за його розширенням (наприклад, `jpg`, `pdf`, `py`, `_no_ext`) і **копіює** туди файл.
Обробляються винятки доступу, відсутності файлів, тощо. `DEST_DIR`, якщо він знаходиться всередині `SRC_DIR`, **пропускається**, щоб уникнути циклу копіювання.

---

## Завдання 2 — «Сніжинка Коха» (рекурсія)

**Синопсис**
```bash
python task2_koch_snowflake.py --level 4 --length 300 --speed 0
```
- `--level` — рівень рекурсії (типово `3`).
- `--length` — довжина сторони базового трикутника (типово `300`).
- `--speed` — швидкість малювання `turtle` від `0` (миттєво) до `10` (типово `0`).

Вікно `turtle` відкриється та намалює фрактал. Закрийте його після перегляду.

---

## Завдання 3 — Бенчмарк сортувань

**Синопсис**
```bash
python task3_sort_benchmark.py --sizes 1000 5000 10000 --repeats 3 --save-csv results.csv
```
- Порівнюються: **Merge Sort**, **Insertion Sort**, **Timsort** (`sorted`).
- Набори даних: `random`, `sorted`, `reversed`, `almost` (10% елементів перетасовано).
- Результати друкуються у вигляді таблиці; опційно зберігаються у CSV.

### Теоретичні оцінки
- **Insertion Sort**: `O(n^2)` середній/гірший випадок, `O(n)` на **майже відсортованих**.
- **Merge Sort**: гарантовано `O(n log n)`, стабільний, але з додатковою пам’яттю.
- **Timsort** (вбудований): комбінація підходів з оптимізаціями для «природних» runs → дуже швидкий у реальних даних.

Нижче — приклад емпіричних результатів (ваші можуть відрізнятися).

## Приклад емпіричних результатів

(На вашій машині цифри будуть відрізнятися; нижче — результат запуску з тими ж налаштуваннями в середовищі перевірки.)

| Algorithm | Data | n | Avg time (s) |
|---|---|---:|---:|
| Insertion | almost | 1000 | 0.011053 |
| Merge | almost | 1000 | 0.001718 |
| Timsort | almost | 1000 | 0.000082 |
| Insertion | random | 1000 | 0.018999 |
| Merge | random | 1000 | 0.001863 |
| Timsort | random | 1000 | 0.000125 |
| Insertion | almost | 10000 | 0.525709 |
| Merge | almost | 10000 | 0.023136 |
| Timsort | almost | 10000 | 0.000847 |
| Insertion | random | 10000 | 2.236769 |
| Merge | random | 10000 | 0.026668 |
| Timsort | random | 10000 | 0.001732 |

### Висновки
- **Timsort** послідовно найшвидший або близький до найшвидшого на всіх наборах, особливо на `almost` та `sorted` завдяки виявленню природних «run»-ів і використанню вставок на малих підмасивах.
- **Insertion Sort** демонструє дуже погану масштабованість на `random`/`reversed` (квадратичний час), але може бути конкурентним на малих або майже відсортованих наборах.
- **Merge Sort** забезпечує стабільну O(n log n) продуктивність без стрибків, однак зазвичай повільніший за Timsort через константи та додаткові копіювання.

Отже, **поєднання злиття та вставок в Timsort** робить його в реальних задачах значно ефективнішим, що підтверджує практику використання **вбудованих** алгоритмів Python замість написання власних.
